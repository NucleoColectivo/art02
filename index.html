<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arte Corporal Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1.5rem;
            color: white;
            z-index: 10;
        }
        .overlay h1, .overlay p {
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .ui-interactive {
            pointer-events: auto;
        }
        #video-preview {
            position: absolute;
            /* Posicionado con top/left para facilitar el arrastre */
            top: calc(100vh - 90px - 1.5rem);
            left: calc(100vw - 120px - 1.5rem);
            width: 120px;
            height: 90px;
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            object-fit: cover;
            transform: scaleX(-1); /* Efecto espejo */
            z-index: 20;
            pointer-events: auto;
            display: none; /* Oculto hasta que se inicie */
            cursor: move; /* Cursor para indicar que es movible */
        }
        .scene-switcher {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
        }
        .scene-switcher button {
            background-color: transparent;
            border: 1px solid transparent;
        }
        .scene-switcher button.active {
            background-color: #8B5CF6; /* purple-500 */
            border-color: #A78BFA; /* purple-400 */
        }
        .loader-icon {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Contenedor principal de la UI -->
    <div id="ui-container">
        <!-- Capa superpuesta para controles -->
        <div class="overlay">
            <!-- Controles superiores izquierdos (Generador de Paleta) -->
            <div class="ui-interactive self-start">
                <div class="flex items-center space-x-2">
                    <input type="text" id="theme-input" placeholder="Ej: bosque neón..." class="bg-black bg-opacity-50 border border-gray-600 rounded-md px-3 py-2 text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-500 transition w-40 md:w-64">
                    <button id="generate-palette-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md text-sm transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg flex items-center justify-center min-w-[150px]">
                        <span id="button-text">✨ Generar Paleta</span>
                    </button>
                </div>
                <p id="gemini-status" class="text-xs text-gray-400 mt-1 h-4"></p>
            </div>
            <!-- Selector de escena en la parte inferior -->
            <div class="absolute bottom-0 left-1/2 -translate-x-1/2 text-center pb-6 w-full px-4">
                <div id="scene-switcher-container" class="scene-switcher ui-interactive inline-flex flex-wrap justify-center gap-2 p-1 rounded-lg">
                    <button data-mode="sphere" class="active text-white font-bold py-2 px-4 rounded-md text-sm transition-all">Esfera</button>
                    <button data-mode="plane" class="text-white font-bold py-2 px-4 rounded-md text-sm transition-all">Plano Espectral</button>
                    <button data-mode="chromaticWeave" class="text-white font-bold py-2 px-4 rounded-md text-sm transition-all">Tejido</button>
                </div>
            </div>
        </div>

        <!-- Pantalla de inicio para solicitar permisos -->
        <div id="start-screen" class="absolute inset-0 flex items-center justify-center z-20 bg-black">
            <div class="text-center p-4">
                 <h1 class="text-4xl md:text-6xl font-bold text-white mb-2">Arte Corporal Interactivo</h1>
                <p class="text-lg text-gray-300 mb-8">Una experiencia visual reactiva a tu voz y silueta.</p>
                <button id="start-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-all duration-300 ease-in-out transform hover:scale-105 shadow-lg">
                    Iniciar
                </button>
                <p id="error-message" class="mt-4 text-red-400"></p>
            </div>
        </div>
        <!-- Elemento de video para la previsualización de la cámara -->
        <video id="video-preview" autoplay playsinline muted></video>
    </div>

    <!-- Import Map para gestionar las dependencias de Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Script principal de la aplicación -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Selección de elementos del DOM ---
        const startButton = document.getElementById('start-button');
        const startScreen = document.getElementById('start-screen');
        const errorMessage = document.getElementById('error-message');
        const themeInput = document.getElementById('theme-input');
        const generatePaletteButton = document.getElementById('generate-palette-button');
        const buttonText = document.getElementById('button-text');
        const geminiStatus = document.getElementById('gemini-status');
        const videoElement = document.getElementById('video-preview');
        const sceneSwitcherContainer = document.getElementById('scene-switcher-container');

        // --- Variables globales ---
        let scene, camera, renderer, composer, controls, clock;
        let audioContext, analyser, dataArray, frequencyTexture, smoothedFrequencyData;
        let targetColors = null;
        let transitionProgress = 1;
        let smoothedAudioLevel = 0;
        let currentVisualizer = null;
        let videoTexture;
        let currentPaletteHex = ["#FF6B6B", "#FFD166", "#06D6A0", "#118AB2", "#073B4C"];

        // --- Shaders (GLSL) ---
        const commonFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
                if (alpha < 0.01) discard;
                gl_FragColor = vec4(vColor, alpha * vAlpha);
            }
        `;
        
        // --- Ruido Simplex 3D (para varios efectos) ---
        const noiseGLSL = `
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
            vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
            float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod(Pi0,289.0);Pi1=mod(Pi1,289.0);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0/7.0;vec4 gy0=fract(floor(gx0)/7.0)-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1/7.0;vec4 gy1=fract(floor(gx1)/7.0)-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}
        `;

        const sphereVertexShader = `
            uniform float uTime;
            uniform float uAudioLevel;
            uniform sampler2D uVideoTexture;
            attribute vec3 initialPosition;
            varying vec3 vColor;
            varying float vAlpha;
            ${noiseGLSL}
            void main() {
                vColor = color;
                vAlpha = 1.0;
                vec3 pos = initialPosition;
                vec3 normal = normalize(initialPosition);
                float noise = cnoise(initialPosition * 0.05 + uTime * 0.3) * 8.0;
                pos += normal * noise;
                vec4 screenPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                vec2 uv = screenPos.xy / screenPos.w * 0.5 + 0.5;
                uv.x = 1.0 - uv.x;
                vec4 videoColor = texture2D(uVideoTexture, uv);
                float brightness = (videoColor.r + videoColor.g + videoColor.b) / 3.0;
                float displacement = brightness * 60.0 * (1.0 + uAudioLevel * 5.0);
                pos += normal * displacement;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = 2.0 * (1.0 + uAudioLevel) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        const planeVertexShader = `
            uniform sampler2D uFrequencyTexture;
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                vColor = color;
                vAlpha = 1.0;
                vec3 pos = position;
                float freq = texture2D(uFrequencyTexture, vec2(uv.x, 0.5)).r;
                pos.z += freq * 50.0;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = 2.5 * (1.0 + freq);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        const chromaticWeaveVertexShader = `
            uniform sampler2D uVideoTexture;
            uniform float uAudioLevel;
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                vColor = color;
                vAlpha = 1.0;
                vec3 pos = position;
                vec2 uv = vec2(pos.x / 200.0 + 0.5, pos.y / 200.0 + 0.5);
                uv.x = 1.0 - uv.x;
                float brightness = texture2D(uVideoTexture, uv).r;
                pos.z = brightness * (50.0 + uAudioLevel * 100.0);
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = 2.0;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        // --- Objeto de Visualizadores ---
        const visualizers = {
            sphere: {
                mesh: null,
                init: () => {
                    const particleCount = 8000;
                    const geometry = createParticleGeometry(particleCount, (i, positions, colors, palette) => {
                        const i3 = i * 3;
                        const radius = 50;
                        const phi = Math.acos(-1 + (2 * i) / particleCount);
                        const theta = Math.sqrt(particleCount * Math.PI) * phi;
                        positions[i3] = radius * Math.cos(theta) * Math.sin(phi);
                        positions[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                        positions[i3 + 2] = radius * Math.cos(phi);
                        const color = palette[i % palette.length];
                        colors[i3] = color.r; colors[i3 + 1] = color.g; colors[i3 + 2] = color.b;
                    });
                    geometry.setAttribute('initialPosition', new THREE.BufferAttribute(geometry.attributes.position.array.slice(), 3));
                    const material = createShaderMaterial(sphereVertexShader, { uVideoTexture: { value: videoTexture } });
                    visualizers.sphere.mesh = new THREE.Points(geometry, material);
                    scene.add(visualizers.sphere.mesh);
                },
                update: (time) => {
                    const uniforms = visualizers.sphere.mesh.material.uniforms;
                    uniforms.uTime.value = time;
                    uniforms.uAudioLevel.value = smoothedAudioLevel;
                }
            },
            plane: {
                mesh: null,
                init: () => {
                    const segments = 63;
                    const geometry = new THREE.PlaneGeometry(200, 200, segments, segments);
                    const colors = new Float32Array((segments + 1) * (segments + 1) * 3);
                    const palette = currentPaletteHex.map(c => new THREE.Color(c));
                    for (let i = 0; i < colors.length / 3; i++) {
                        const color = palette[i % palette.length];
                        colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
                    }
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = createShaderMaterial(planeVertexShader, { uFrequencyTexture: { value: frequencyTexture } });
                    visualizers.plane.mesh = new THREE.Points(geometry, material);
                    visualizers.plane.mesh.rotation.x = -Math.PI / 2.5;
                    scene.add(visualizers.plane.mesh);
                },
                update: (time) => {
                    for(let i = 0; i < dataArray.length; i++) {
                        smoothedFrequencyData[i] = THREE.MathUtils.lerp(smoothedFrequencyData[i], dataArray[i] / 255, 0.15);
                    }
                    frequencyTexture.needsUpdate = true;
                }
            },
            chromaticWeave: {
                mesh: null,
                init: () => {
                    const segments = 80;
                    const geometry = new THREE.PlaneGeometry(200, 200, segments, segments);
                    const colors = new Float32Array((segments + 1) * (segments + 1) * 3);
                    const palette = currentPaletteHex.map(c => new THREE.Color(c));
                    for (let i = 0; i < colors.length / 3; i++) {
                        const color = palette[i % palette.length];
                        colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
                    }
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = createShaderMaterial(chromaticWeaveVertexShader, { uVideoTexture: { value: videoTexture } });
                    visualizers.chromaticWeave.mesh = new THREE.Points(geometry, material);
                    scene.add(visualizers.chromaticWeave.mesh);
                },
                update: (time) => {
                     visualizers.chromaticWeave.mesh.material.uniforms.uAudioLevel.value = smoothedAudioLevel;
                }
            }
        };

        // --- Funciones de ayuda para geometrías y materiales ---

        function createParticleGeometry(count, setupFn) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const randoms = new Float32Array(count);
            const palette = currentPaletteHex.map(c => new THREE.Color(c));
            for (let i = 0; i < count; i++) {
                setupFn(i, positions, colors, palette);
                randoms[i] = Math.random();
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
            return geometry;
        }
        
        function createShaderMaterial(vertexShader, uniforms = {}) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uAudioLevel: { value: 0.0 },
                    ...uniforms
                },
                vertexShader: vertexShader,
                fragmentShader: commonFragmentShader,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
        }
        
        // --- Funciones principales de la aplicación ---

        function switchVisualizer(name) {
            if (currentVisualizer === visualizers[name] && scene.children.length > 0) return;

            if (currentVisualizer && currentVisualizer.mesh) {
                scene.remove(currentVisualizer.mesh);
                currentVisualizer.mesh.geometry.dispose();
                currentVisualizer.mesh.material.dispose();
                if(currentVisualizer.mesh.material.uniforms.uVideoTexture?.value) {
                    // No disponer de la textura de video, se reutiliza
                }
            }
            
            // Ajustes de cámara
            camera.position.set(0, 0, 100);
            controls.target.set(0, 0, 0);
             if (name === 'plane') {
                camera.position.set(0, 80, 100);
            } else if (name === 'chromaticWeave') {
                camera.position.set(0, 0, 150);
            }

            currentVisualizer = visualizers[name];
            currentVisualizer.init();
            
            // Actualizar UI
            document.querySelectorAll('.scene-switcher button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === name);
            });
        }
        
        async function getPaletteFromGemini(prompt) {
             geminiStatus.textContent = 'Generando paleta con Gemini...';
            generatePaletteButton.disabled = true;
            buttonText.innerHTML = `<svg class="loader-icon -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Generando...`;

            const payload = {
                contents: [{ parts: [{ text: `Genera una paleta de 5 códigos hexadecimales basada en el tema: "${prompt}". Los colores deben ser vibrantes y funcionar bien para un visualizador con fondo negro.` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: { type: "OBJECT", properties: { "colors": { "type": "ARRAY", "items": { "type": "STRING" } } } }
                }
            };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`Error HTTP: ${response.status}`);
                const result = await response.json();
                const jsonText = result.candidates[0].content.parts[0].text;
                const parsedJson = JSON.parse(jsonText);
                if (parsedJson.colors && parsedJson.colors.length > 0) {
                    updatePalette(parsedJson.colors);
                    geminiStatus.textContent = '¡Paleta actualizada!';
                } else {
                     geminiStatus.textContent = 'Respuesta inválida de la API.';
                }
            } catch (error) {
                console.error("Error al llamar a la API de Gemini:", error);
                geminiStatus.textContent = 'Error al generar la paleta.';
            } finally {
                generatePaletteButton.disabled = false;
                buttonText.innerHTML = '✨ Generar Paleta';
                setTimeout(() => { geminiStatus.textContent = ''; }, 3000);
            }
        }

        function updatePalette(newColorsHex) {
            if (!currentVisualizer || !currentVisualizer.mesh) return;
            currentPaletteHex = newColorsHex;
            const newColors = newColorsHex.map(hex => new THREE.Color(hex));
            const colorBuffer = currentVisualizer.mesh.geometry.attributes.color;
            targetColors = new Float32Array(colorBuffer.count * 3);
            
            for (let i = 0; i < colorBuffer.count; i++) {
                const paletteColor = newColors[i % newColors.length];
                targetColors[i * 3] = paletteColor.r;
                targetColors[i * 3 + 1] = paletteColor.g;
                targetColors[i * 3 + 2] = paletteColor.b;
            }
            transitionProgress = 0;
        }
        
        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; bloomPass.strength = 0.9; bloomPass.radius = 0;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bassLevel = dataArray.slice(0, 32).reduce((a, b) => a + b, 0) / 32 / 255;
                smoothedAudioLevel = THREE.MathUtils.lerp(smoothedAudioLevel, bassLevel, 0.1);

                if (currentVisualizer) {
                    currentVisualizer.update(time);
                }

                if (targetColors && transitionProgress < 1) {
                    transitionProgress = Math.min(transitionProgress + 0.02, 1);
                    const colorBuffer = currentVisualizer.mesh.geometry.attributes.color;
                    for (let i = 0; i < colorBuffer.count; i++) {
                        const i3 = i * 3;
                        colorBuffer.array[i3] = THREE.MathUtils.lerp(colorBuffer.array[i3], targetColors[i3], transitionProgress);
                        colorBuffer.array[i3 + 1] = THREE.MathUtils.lerp(colorBuffer.array[i3 + 1], targetColors[i3 + 1], transitionProgress);
                        colorBuffer.array[i3 + 2] = THREE.MathUtils.lerp(colorBuffer.array[i3 + 2], targetColors[i3 + 2], transitionProgress);
                    }
                    colorBuffer.needsUpdate = true;
                }
            }
            controls.update();
            composer.render();
        }

        async function startMedia() {
            try {
                const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                videoElement.srcObject = mediaStream;
                videoElement.style.display = 'block';

                videoTexture = new THREE.VideoTexture(videoElement);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(mediaStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                smoothedFrequencyData = new Float32Array(dataArray.length);
                frequencyTexture = new THREE.DataTexture(smoothedFrequencyData, dataArray.length, 1, THREE.RedFormat, THREE.FloatType);
                
                startScreen.style.display = 'none';
                switchVisualizer('sphere');
                animate();
            } catch (err) {
                console.error("Error al acceder a los medios:", err);
                errorMessage.textContent = "Acceso a cámara/micófono denegado. Revisa los permisos.";
            }
        }
        
        // --- Asignación de Eventos ---
        generatePaletteButton.addEventListener('click', () => {
            const prompt = themeInput.value;
            if (prompt) getPaletteFromGemini(prompt);
        });
        themeInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') generatePaletteButton.click(); });
        
        startButton.addEventListener('click', () => { 
            init(); 
            startMedia(); 
        });

        sceneSwitcherContainer.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const mode = event.target.dataset.mode;
                if (mode) {
                    switchVisualizer(mode);
                }
            }
        });

        // --- Lógica para arrastrar la ventana de video ---
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;

        videoElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            e.preventDefault();
            
            offsetX = e.clientX - videoElement.offsetLeft;
            offsetY = e.clientY - videoElement.offsetTop;
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        function onMouseMove(e) {
            if (!isDragging) return;
            
            let newLeft = e.clientX - offsetX;
            let newTop = e.clientY - offsetY;

            const bodyRect = document.body.getBoundingClientRect();
            const videoRect = videoElement.getBoundingClientRect();
            newLeft = Math.max(0, Math.min(newLeft, bodyRect.width - videoRect.width));
            newTop = Math.max(0, Math.min(newTop, bodyRect.height - videoRect.height));

            videoElement.style.left = `${newLeft}px`;
            videoElement.style.top = `${newTop}px`;
        }

        function onMouseUp() {
            isDragging = false;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
    </script>
</body>
</html>

